<!DOCTYPE html>
<html lang="en" style="width:100%;height: 100%">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript" src="./jtopo-0.4.8-min.js"></script>
    <script type="text/javascript" src="../../../node_modules/lodash/lodash.js"></script>
</head>
<body style="width:100%;height: 100%" onresize="resize()">
<canvas width="800" height="800" id="canvas" style="background-image: url(./graphback.png);background-repeat: repeat;border-right: 1px solid whitesmoke"></canvas>
</div>
</body>
<script>
  window.requestAnimFrame = (function(callback) {
    return window.requestAnimationFrame
      || window.webkitRequestAnimationFrame
      || window.mozRequestAnimationFrame
      || window.oRequestAnimationFrame
      || window.msRequestAnimationFrame
      || function(callback) {
           window.setTimeout(callback, 1000 / 60);
         };
  })();

  this.height = 600;
  this.width = 800;
  this.spineContainer = null;
  this.leafContainer = null;
  this.otherContainer = null;
  this.spineContainerLeftNode = null;
  this.spineContainerRightNode = null;
  this.spineContainerText = null;

  this.leafContainerLeftNode = null;
  this.leafContainerRightNode = null;
  this.leafContainerText = null;

  this.otherContainerLeftNode = null;
  this.otherContainerRightNode = null;
  this.otherContainerText = null;

  this.stage = null;
  this.scene = null;

  this.spines = {};
  this.leafs = {};
  this.others = {};
  this.links = {};
  this.switchLocation = {};


  let scope = {
    "spines":[{'id':'11_spine'}, {'id':'22_spine'}, {'id':'33_spine'}],
    "leafs":[{'id':'11_leaf','leaf_group':1},{'id':'44_leaf','leaf_group':3}, {'id':'22_leaf','leaf_group':1},{'id':'33_leaf','leaf_group':4} ,{'id':'55_leaf','leaf_group':3}, {'id':'66_leaf','leaf_group':2},
      {'id':'11_leaf1','leaf_group':11},{'id':'44_leaf1','leaf_group':31}, {'id':'22_leaf1','leaf_group':11},{'id':'33_leaf1','leaf_group':41} ,{'id':'55_leaf1','leaf_group':31}, {'id':'66_leaf1','leaf_group':21}],
    "others":[{'id':'11_other'}, {'id':'22_other'}, {'id':'33_other'}],
    "links": [
      {
        "src": {
          "port": "1",
          "device": "11_spine"
        },
        "dst": {
          "port": "3",
          "device": "11_leaf"
        },
        "type": "DIRECT",
        "state": "ACTIVE"
      },
      {
        "src": {
          "port": "3",
          "device": "22_spine"
        },
        "dst": {
          "port": "2",
          "device": "22_leaf"
        },
        "type": "DIRECT",
        "state": "ACTIVE"
      },
      {
        "src": {
          "port": "3",
          "device": "11_leaf"
        },
        "dst": {
          "port": "2",
          "device": "22_leaf"
        },
        "type": "DIRECT",
        "state": "DOWN"
      }
    ]
  }
  let self = this;
  let initialize = () => {
    let canvas = document.getElementById("canvas");


    var context = canvas.getContext('2d');
    // 设置文字阴影的颜色为黑色，透明度为20%
    context.shadowColor = 'rgba(0, 0, 0, 1)';
    // 将阴影向右移动15px，向上移动10px
    context.shadowOffsetX = 20;
    context.shadowOffsetY = 20;
    // 轻微模糊阴影
    context.shadowBlur = 20;
    context.shadowColor = '0,0,0';


//    this.stage = new JTopo.Stage(canvas); // 创建一个舞台对象
//    this.scene = new JTopo.Scene(this.stage);

//    this.spineContainer = new JTopo.Container();
//    this.leafContainer = new JTopo.Container();
//    this.otherContainer = new JTopo.Container();
//
//    this.spineContainer.fillColor = '255,255,255';
////    this.leafContainer.fillColor = '239,239,239';
//    this.leafContainer.fillColor = '255,255,255';
//    this.otherContainer.fillColor = '255,255,255';
//
//
//
//    this.spineContainer.dragable = false;
//    this.leafContainer.dragable = false;
//    this.otherContainer.dragable = false;
//
//    this.spineContainer.alpha=0;
//
//    this.leafContainer.alpha=0.1;
//
//    this.otherContainer.alpha=0;
//
//
//    this.spineContainer.showSelected = false;
//    this.leafContainer.showSelected = false;
//    this.otherContainer.showSelected = false;
//
//    this.scene.add(this.spineContainer);
//    this.scene.add(this.leafContainer);
//    this.scene.add(this.otherContainer);

//    genSpine();
//    genLeaf();
//    genOther();
//    genLinks();
//
//    resize();
  };

  let genSpine = () =>{
    this.spineContainerLeftNode = genAnchorNode();
    this.spineContainerRightNode = genAnchorNode();
    this.spineContainerText = genTextNode("Spine Switch");
//    this.spineContainerText.index = 100

    this.spineContainer.add(this.spineContainerLeftNode);
    this.spineContainer.add(this.spineContainerRightNode);
//    this.spineContainer.add(this.spineContainerText);

    this.scene.add(this.spineContainerLeftNode);
    this.scene.add(this.spineContainerRightNode);

    _.forEach(scope.spines, (spine, index)=>{
      this.spines[spine.id] = genNormalNode(spine.id);
    });
//    for(let index in scope.spines){
//      let spine = scope.spines[index];
//      this.spines[spine.id] = genNormalNode(spine.id);
//    }

  }

  let genLeaf = () =>{
    this.leafContainerLeftNode = genAnchorNode();
    this.leafContainerRightNode = genAnchorNode();
    this.leafContainerText = genTextNode("Leaf Switch");

    this.leafContainer.add(this.leafContainerLeftNode);
    this.leafContainer.add(this.leafContainerRightNode);

    this.scene.add(this.leafContainerLeftNode);
    this.scene.add(this.leafContainerRightNode);

//    for(let index in scope.leafs){
//      let leaf = scope.leafs[index];
//      this.leafs[leaf.id] = genNormalNode(leaf.id);
//    }

    _.forEach(scope.leafs, (leaf, index)=>{
      this.leafs[leaf.id] = genNormalNode(leaf.id);
    });

  };

  let genOther = () => {
    this.otherContainerLeftNode = genAnchorNode();
    this.otherContainerRightNode = genAnchorNode();
    this.otherContainerText = genTextNode("Other Switch");

    this.otherContainer.add(this.otherContainerLeftNode);
    this.otherContainer.add(this.otherContainerRightNode);

    this.scene.add(this.otherContainerLeftNode);
    this.scene.add(this.otherContainerRightNode);


    _.forEach(scope.others, (other, index)=>{
      this.others[other.id] = genNormalNode(other.id);
    });
//    for(let index in scope.others){
//      let other = scope.others[index];
//
//      this.others[other.id] = genNormalNode(other.id);
//    }
  }

  let genLinks = () => {

    _.forEach(scope.links, function(link, key) {
      let deviceIds = [link.src.device, link.dst.device];
      let linkId = getLinkId(deviceIds);
      this.links[linkId] = genLinkNode(deviceIds);

      if(link.state != "ACTIVE"){
        this.links[linkId].strokeColor = "255,0,0";
      }
    });

  }

  let getLinkId = (deviceIds) =>{
    deviceIds = _.sortBy(deviceIds);
    return deviceIds[0] + '_' + deviceIds[1];
  }

  let draw = () =>{

    let avgHeight = this.height/3;
    let spineInterval = calcInterval(scope.spines, this.width);
    let leafInterval = calcLeafInterval(scope.leafs, this.width);
    let otherInterval = calcInterval(scope.others, this.width);

    let spineKeys = _.keys(this.spines);
    spineKeys = _.sortBy(spineKeys);
    for(let i = 0; i< spineKeys.length; i++){
      let key = spineKeys[i];
      let node = this.spines[key];
      let x = (i + 1) * spineInterval + i * 16;
      let y =  (avgHeight - 108)/2;
      node.setLocation(x, y);

      this.switchLocation[key] = [x, y];
    }

    this.spineContainerText.setLocation(10, 10);

    let leaf_groups = _.groupBy(scope.leafs, "leaf_group");
    let orderKeys = _.keys(leaf_groups);
    let last_x = 0;
    for(let i = 0; i< orderKeys.length; i++){
      let key = orderKeys[i];
      let leaf_group = leaf_groups[key]; //arr
      for(let j = 0; j < leaf_group.length; j ++){
        let node = this.leafs[leaf_group[j].id];
        let y = (avgHeight - 104)/2 + avgHeight;
        let x = last_x + leafInterval + j * (16+2);
        node.setLocation(x, y);

        this.switchLocation[leaf_group[j].id] = [x, y];
      }
      last_x = last_x + leafInterval +(16+2)* leaf_group.length;
    }
    this.leafContainerText.setLocation(10, 10 + avgHeight);


    let otherKeys = _.keys(this.others);
    otherKeys = _.sortBy(otherKeys);
    for(let i = 0; i< otherKeys.length; i++){
      let key = otherKeys[i];
      let node = this.others[key];
      let x = (i + 1) * otherInterval + i * 16;
      let y =  (avgHeight - 104)/2 + avgHeight * 2;
      node.setLocation(x, y);

      this.switchLocation[key] = [x, y];
    }

    this.otherContainerText.setLocation(10, 10 + avgHeight*2);
  };


  let calcInterval = (nodes, width) =>{
    return (width - 16 * nodes.length)/(nodes.length + 1)
  }

  let calcLeafInterval = (leafs, width) =>{
    let remainWidth = width - 16 * leafs.length;
    let group = _.groupBy(leafs, 'leaf_group');
    return remainWidth/ (_.keys(group).length + 1);
  };

  let genAnchorNode = () =>{
    let node = new JTopo.Node();
    node.dragable = false ;
    node.width = 1;
    node.showSelected =false;
    node.fillColor = "98,98,255";
    return node;
  };

  let genTextNode = (text) =>{
    let node = new JTopo.Node(text);
    node.dragable = false ;
    node.showSelected =false;
    node.font = '16px 微软雅黑';
    node.fontColor = "255,255,255";
    node.fillColor = '200,200,0';
    node.textPosition = 'Middle_Center';
    node.borderRadius = 3;
    node.shadowOffsetX = 3;
    node.shadowOffsetY = 3;
    node.shadowBlur = 3;
    node.shadowColor= '0,0,0';
    node.width = 100;
    node.height = 25;
    this.scene.add(node);
    return node;
  };

  let genNormalNode = (deviceId) =>{
    let node = new JTopo.Node();
    node.dragable = true ;
    node.width = 16;
    node.height = 104;
    node.showSelected =true;
    node.deviceId = deviceId;
    node.move = false;

    node.mouseup(mouseUpHandler);
    node.mousedrag(mouseDragHandler);


    let count = 36;
    let len = 3;
    node.paint = function(g){
      g.beginPath();
      g.rect(-8,-54, 16, 108);
      g.fillStyle = 'rgba(0,0,0,' + this.alpha + ')';
      g.fill();
      g.closePath();

      let padding = (16 - len * 2)/3;
      let left = - 16/2 + padding;
      let right = 16/2 -padding - len;
      let top = 8;
      for(let i = 0; i< count ; i++){
        g.beginPath();
        if(i % 2 === 0){
          g.rect(left, -54 +  6 + parseInt(i/2) * (len + 1), len , len);
        } else {
          g.rect(right, -54 + 6 + parseInt(i/2) * (len + 1), len , len);
        }
        //green
        g.fillStyle ='#81FF1A';
        if(i%10 ===0){
          //red
          g.fillStyle ='rgb(255,0,0)';
        }
        g.fill();
        g.closePath();
      }
      g.save();
      g.restore();

      this.paintText(g);
    };

    this.scene.add(node);
    return node;
  };


  function mouseUpHandler(data){
    if(this.move){
      console.log("move");
      let oldLocation = self.switchLocation[this.deviceId];
      let curLocation = this.getLocation();
      let node = this;
      let starttime = (new Date()).getTime();
      setTimeout(goBack_Animate(oldLocation, curLocation.x, curLocation.y,starttime, node))
    } else {
      console.log("click")
      console.log(this.deviceId)

    }
    this.move = false;
  }
  function goBack_Animate(oldLocation, nowX, nowY,starttime, node){
    let time = (new Date()).getTime() - starttime;
    if(time > 1000) {
      node.setLocation(oldLocation[0], oldLocation[1]);
      return;
    }
    let percentage = time/1000;
    let nP = easeOutElastic(percentage)
    let curX = (oldLocation[0] - nowX) * nP + nowX;
    let curY = (oldLocation[1] - nowY) * nP+ nowY;
    node.setLocation(curX, curY);
    requestAnimFrame(function () {
      goBack_Animate(oldLocation, nowX, nowY, starttime, node);
    })
//
//    let curX = (oldLocation[0] - nowX) * time/1000 + nowX;
//    let curY = (oldLocation[1] - nowY) * time/1000 + nowY;


//    self.count = self.count + 1;
//    if(self.count >= 120){
//      node.setLocation(oldLocation[0], oldLocation[1]);
//      self.count = 0;
//    } else {
//      node.setLocation(curX, curY);
//      requestAnimFrame(function () {
//        goBack_Animate(oldLocation, nowX, nowY, starttime, node);
//      })
//    }
//    if( ( ((curX - oldLocation[0] + 30) >= 0 && (nowX - oldLocation[0]) <= 0)
//      || ((curX - oldLocation[0] + 30) <= 0 && (nowX - oldLocation[0]) >= 0) )
//      && ( ((curY - oldLocation[1] + 30) >= 0 && (nowY - oldLocation[1]) <= 0)
//      || ((curY - oldLocation[1] + 30) <= 0 && (nowY - oldLocation[1]) >= 0) )){
//      node.setLocation(oldLocation[0], oldLocation[1]);

//      if( ( ((curX - oldLocation[0]) >= 0 && (nowX - oldLocation[0]) <= 0)
//        || ((curX - oldLocation[0] ) <= 0 && (nowX - oldLocation[0]) >= 0) )
//        && ( ((curY - oldLocation[1]) >= 0 && (nowY - oldLocation[1]) <= 0)
//        || ((curY - oldLocation[1] ) <= 0 && (nowY - oldLocation[1]) >= 0) )){
//        node.setLocation(oldLocation[0], oldLocation[1]);

//    } else {
//      node.setLocation(curX, curY);
//      requestAnimFrame(function () {
//        goBack_Animate(oldLocation, nowX, nowY, starttime, node);
//      })
//    }
  }
  let c4 = ( 2 * Math.PI ) / 3;
  function easeOutElastic(x) {

    return x === 0 ? 0 : x === 1 ? 1 :
      Math.pow(2, -10 * x) * Math.sin(( x * 10 - 0.75 ) * c4) + 1
  }

  function mouseDragHandler(data){
    this.move = true;
  }

  let genLinkNode = (devices) => {
    let nodeA = this.leafs[devices[0]] || this.spines[devices[0]];
    let nodeB = this.leafs[devices[1]] || this.spines[devices[1]];

    let link = new JTopo.Link(nodeA, nodeB);
    link.zIndex = 20;
    link.lineWidth = 3;
    link.strokeColor = '136,234,136';
    link.dragable = true;
    link.showSelected = false;

    this.scene.add(link);
    return link;
  };

  /*
   负责给container加上两个隐藏的node，用来固定整个容器
   */
  let layout = () =>{
    let avgHeight = this.height/3;

    this.spineContainerLeftNode.setLocation(0,0);
    this.spineContainerRightNode.setLocation(this.width,0);

    this.spineContainerLeftNode.height = avgHeight;
    this.spineContainerRightNode.height = avgHeight;

    this.leafContainerLeftNode.setLocation(0, avgHeight);
    this.leafContainerRightNode.setLocation(this.width, avgHeight);

    this.leafContainerLeftNode.height = avgHeight;
    this.leafContainerRightNode.height = avgHeight;

    this.otherContainerLeftNode.setLocation(0, avgHeight*2);
    this.otherContainerRightNode.setLocation(this.width, avgHeight*2);

    this.otherContainerLeftNode.height = avgHeight;
    this.otherContainerRightNode.height = avgHeight;
  };
  let timeOut = null;
  let resize = () => {

    if(timeOut){
      clearTimeout(timeOut);
    }
    timeOut = setTimeout(()=>{
      let canvas = document.getElementById("canvas");
      this.height = canvas.parentNode.offsetHeight;
      this.width = canvas.parentNode.offsetWidth;
      canvas.width = this.width;
      canvas.height = this.height;

      var context = canvas.getContext('2d');
      context.shadowColor = 'rgba(0, 0, 0, 0.2)';
      context.shadowOffsetX = 5;
      context.shadowOffsetY = 5;
      context.shadowBlur = 5;

//      this.leafContainer.shadowColor = 'rgba(255, 255, 0, 1)';
      layout();
      draw();
    },100);

  };

  initialize();

</script>
</html>